#!/usr/bin/env nextflow

nextflow.enable.dsl=2
//params.mgmt_promoter_r_script = "mnt/scripts/MGMT_Prospective2.R"
// Define the base path as a parameter

// params.path = "/home/chbope/extension"


// params.epi2me_dir="/home/chbope/Documents/nanopore/epi2me/wf-human-variation-master/"
// params.episv ="/home/chbope/extension/results/epi2me/episv"
// params.epimodkit ="/home/chbope/extension/results/epi2me/epimodkit"
// params.epicnv ="/home/chbope/extension/results/epi2me/epicnv"

// input reference files for all samples

// params.reference_genome = file("/home/chbope/extension/data/reference/GCF_000001405.39_GRCh38.p13_genomic_chr_only_plus_mt.fa")
// params.reference_genome_bai = file("/home/chbope/extension/data/reference/CF_000001405.39_GRCh38.p13_genomic_chr_only_plus_mt.fa.fai")


// params.tr_bed_file = file("/home/chbope/extension/data/reference/human_GRCh38_trf.bed")
// //params.epi2me_config_file = file("/home/chbope/Documents/nanopore/epi2me/wf-human-variation-master/nextflow.config")
// params.epi2me_config_file = file("/home/chbope/Documents/nanopore/nextflow/pipeline/configs/pipeline1.config")
// //params.epi2me_base_config_file = file("/home/chbope/Documents/nanopore/epi2me/wf-human-variation-master/base.config")
// //input individual samples files

// //input file folder
// merge_bam_folder = "/home/chbope/extension/Data_for_Bope/single_bam_folder"



// Define the available run modes


//##############################3
//## Extract overlapping EPIC sites for methylation based classification 
//#############################

//# wf_mods_bedmethyl generated by modkit in Epi2me-labs on the P24
//# EPIC_sites_NEW.bed contains chromosomal coordinates and names of EPIC 850 probes
//# Uses Bedtools intersect, awk and sed


//epi2me pipeline to run modkit

process run_epi2me_modkit {
    cpus 4
    memory '16 GB'
    label 'pipeline1'
   // publishDir "${params.output_path}/epi2me/modkit/", mode: "copy", pattern: "epimodkit/*"

    input:
    tuple val(sample_id), path(bam), path(bai), path(reference_genome), path(reference_genome_bai), path(tr_bed_file), path(epimodkit)

    output:
    tuple val(sample_id), path("epimodkit")

    script:
    """
    nextflow run '${params.epi2me_dir}' \
        --bam '${bam}' \
        --ref '${reference_genome}' \
        --sample_name '${sample_id}' \
        --mod \
        --out_dir  'epimodkit' \
        --annotate FALSE \
        --threads ${params.threads} \
        --basecaller_basemod_threads ${params.threads} \
        --tr_bed '${tr_bed_file}' \
        --disable_ping \
        -profile singularity 
    """
}

//epi2me pipeline to run sv with sniffles2 with mosaic option
process run_epi2me_sv {
    cpus 4
    memory '16 GB'
    label 'pipeline1'
   // publishDir "${params.output_path}/epi2me/sv/", mode: "copy", pattern: "episv/*"

    input:
    tuple val(sample_id), path(bam), path(bai), path(reference_genome), path(reference_genome_bai), path(tr_bed_file), path(episv)

    output:
    tuple val(sample_id), path("episv")

    script:
    """
    nextflow run '${params.epi2me_dir}' \
        --bam '${bam}' \
        --ref '${reference_genome}' \
        --sample_name '${sample_id}' \
        --sv \
        --out_dir  'episv' \
        --threads ${params.threads} \
        --basecaller_basemod_threads ${params.threads} \
        --tr_bed '${tr_bed_file}' \
        --disable_ping \
        -profile singularity
    """
}

//epi2me pipeline to run cnv qdnaseq
process run_epi2me_cnv {
    cpus 4
    memory '8 GB'
    label 'epi2me'
    //publishDir "${params.output_path}/epi2me/cnv/", mode: "copy", pattern: "epicnv/**"

    input:
    tuple val(sample_id), path(bam), path(bai), path(reference_genome), path(reference_genome_bai), path(tr_bed_file), path(epicnv)

    output:
    tuple val(sample_id), 
          path("epicnv")
    
    script:
    """
    nextflow run '${params.epi2me_dir}' \
        --bam '${bam}' \
        --ref '${reference_genome}' \
        --sample_name ${sample_id} \
        --cnv \
        --out_dir  'epicnv' \
        --threads ${params.threads} \
        --basecaller_basemod_threads ${params.threads} \
        --tr_bed '${tr_bed_file}' \
        --disable_ping \
        -profile singularity
    """
}

workflow epi2me {
    take:
        merged_data
        
    main:
        params.run_mode = params.run_mode_epi2me ?: 'all'
        println "epi2me run mode: ${params.run_mode}"

        // Validate required parameters
        if (!params.reference_genome) {
            error "ERROR: Reference genome path not specified (params.reference_genome)"
        }
        if (!params.reference_genome_bai) {
            error "ERROR: Reference genome index path not specified (params.reference_genome_bai)"
        }
        if (!params.tr_bed_file) {
            error "ERROR: TR BED file path not specified (params.tr_bed_file)"
        }

        // Create file objects for reference files
        reference_genome = file(params.reference_genome)
        reference_genome_bai = file(params.reference_genome_bai)
        tr_bed_file = file(params.tr_bed_file)
        episv = file(params.episv)
        epimodkit = file(params.epimodkit)
        epicnv = file(params.epicnv)    

        // Validate reference files exist
        if (!reference_genome.exists()) {
            error "ERROR: Reference genome file not found: ${params.reference_genome}"
        }
        if (!reference_genome_bai.exists()) {
            error "ERROR: Reference genome index file not found: ${params.reference_genome_bai}"
        }
        if (!tr_bed_file.exists()) {
            error "ERROR: TR BED file not found: ${params.tr_bed_file}"
        }

        // Validate run_mode parameter
        if (!['modkit', 'cnv', 'sv', 'all'].contains(params.run_mode)) {
            error "ERROR: Invalid run_mode '${params.run_mode}' for epi2me. Valid modes: modkit, cnv, sv, all."
        }

        // Create input channel based on run mode
        input_channel = params.run_order_mode ? 
            merged_data.map { sid, bam, bai -> 
                tuple(
                    sid, 
                    bam, 
                    bai,
                    reference_genome,
                    reference_genome_bai,
                    tr_bed_file
                )
            } : Channel
            .from(file(params.epi2me_sample_id_file).readLines())
            .map { line ->
                def fields = line.tokenize("\t")
                def sample_id = fields[0].trim()
                def bam = file("${params.merge_bam_folder}/${sample_id}.*.bam")
                def bai = file("${params.merge_bam_folder}/${sample_id}.*.bam.bai")

                bam = bam.find()
                bai = bai.find()

                if (!bam || !bai) {
                    error "BAM file or index file not found for sample ID: ${sample_id}"
                }

                return tuple(
                    sample_id, 
                    bam, 
                    bai,
                    reference_genome,
                    reference_genome_bai,
                    tr_bed_file
                )
            }

        // Run processes based on mode
        modkit_ch = Channel.empty()
        cnv_ch = Channel.empty()
        sv_ch = Channel.empty()

        if (params.run_mode in ['modkit', 'all']) {
            println "Running modkit..."
            modkit_ch = input_channel.map { sid, bam, bai, ref, ref_bai, tr_bed ->
                tuple(
                    sid, 
                    bam, 
                    bai, 
                    ref, 
                    ref_bai, 
                    tr_bed, 
                    file("${params.epimodkit}")
                )
            } | run_epi2me_modkit
        }

        if (params.run_mode in ['cnv', 'all']) {
            println "Running cnv..."
            cnv_ch = input_channel.map { sid, bam, bai, ref, ref_bai, tr_bed ->
                tuple(
                    sid, 
                    bam, 
                    bai, 
                    ref, 
                    ref_bai, 
                    tr_bed, 
                    file("${params.epicnv}")
                )
            } | run_epi2me_cnv
        }

        if (params.run_mode in ['sv', 'all']) {
            println "Running sv..."
            sv_ch = input_channel.map { sid, bam, bai, ref, ref_bai, tr_bed ->
                tuple(
                    sid, 
                    bam, 
                    bai, 
                    ref, 
                    ref_bai, 
                    tr_bed, 
                    file("${params.episv}")
                )
            } | run_epi2me_sv
            
            // Wait for SV completion
    
        }

        // Create default channels for empty processes
        default_modkit = input_channel.map { sid, bam, bai, ref, ref_bai, tr_bed -> 
            tuple(sid, file("${params.epimodkit}/${sid}_wf_mods.bedmethyl.gz")) 
        }
        
        default_cnv = input_channel.map { sid, bam, bai, ref, ref_bai, tr_bed -> 
            tuple(
                sid, 
                file("${params.epicnv}/qdna_seq/${sid}_segs.bed"),
                file("${params.epicnv}/qdna_seq/${sid}_bins.bed"),
                file("${params.epicnv}/qdna_seq/${sid}_segs.vcf")
            )
        }
        
        default_sv = input_channel.map { sid, bam, bai, ref, ref_bai, tr_bed -> 
            tuple(sid, file("${params.episv}/${sid}_wf_sv.vcf.gz"))
        }

        // Mix actual results with defaults
        modkit_results = modkit_ch.mix(default_modkit)
        cnv_results = cnv_ch.mix(default_cnv)
        sv_results = sv_ch.mix(default_sv)

        // Combine all results
        results_ch = input_channel
            .join(modkit_results, by: 0)
            .join(cnv_results, by: 0)
            .join(sv_results, by: 0)
            .map { sample_id, bam, bai, ref, ref_bai, tr_bed, modkit, segs_bed, bins_bed, segs_vcf, sv ->
            tuple(
                sample_id,
                bam,
                bai,
                ref,
                ref_bai,
                tr_bed,
                modkit,
                segs_bed,
                bins_bed,
                segs_vcf,
                sv
            )
        }

    emit:
        results = results_ch
}
    